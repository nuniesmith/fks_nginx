## =================================================================
## FKS Trading Systems - Gateway (No Authelia)
## Provides basic reverse proxy + optional JWT presence check.
## =================================================================

# Upstreams (match service names on fks_net)
upstream api_backend  { server fks_api:8000;  keepalive 16; }
upstream web_backend  { server fks_web:80;    keepalive 16; }
upstream data_backend { server fks_data:4200; keepalive 8; }
upstream auth_backend { server fks_auth:4100; keepalive 8; }

map $http_upgrade $connection_upgrade { default upgrade; '' close; }

# Minimal CORS allow-list (adjust as needed)
map $http_origin $cors_allow_origin {
    default "";
    ~^https?://(www\.)?fkstrading\.test$ $http_origin;
    ~^https?://(www\.)?fkstrading\.xyz$ $http_origin;
}

# Basic rate limits
limit_req_zone $binary_remote_addr zone=api_rate:10m rate=20r/s;
limit_req_zone $binary_remote_addr zone=web_rate:10m rate=50r/s;


# Redirect HTTP -> HTTPS (root + www + localhost)
server {
    listen 80;
    server_name localhost fkstrading.test www.fkstrading.test fkstrading.xyz www.fkstrading.xyz;    
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    http2 on;
    server_name localhost fkstrading.test www.fkstrading.test fkstrading.xyz www.fkstrading.xyz;
    client_max_body_size 2G;

    ssl_certificate     /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;

    # Basic headers
    add_header X-Frame-Options SAMEORIGIN always;
    add_header X-Content-Type-Options nosniff always;

    # Health
    location = /health { access_log off; return 200 "nginx:ok\n"; }

    # Static assets
    location /static/ {
        proxy_pass http://web_backend/static/;
        proxy_set_header Host $host;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # Generic static extensions
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|webp|woff2?)$ {
        proxy_pass http://web_backend$request_uri;
        proxy_set_header Host $host;
        expires 7d;
        add_header Cache-Control "public, max-age=604800";
    }

    # API prefix (JWT required via auth_request -> /verify on auth service)
    location /api/ {
        limit_req zone=api_rate burst=40 nodelay;
        auth_request /__jwt_verify;
        error_page 401 = @api_unauthorized;
        proxy_pass http://api_backend$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_read_timeout 300s;
    }

    # Internal subrequest location for JWT verification (never exposed)
    location = /__jwt_verify {
        internal;
        proxy_pass http://auth_backend/verify;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
    }

    location @api_unauthorized {
        add_header Content-Type application/json always;
        return 401 '{"error":"unauthorized"}';
    }

    # Data prefix
    location /data/ {
        proxy_pass http://data_backend/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # SPA root
    location / {
        limit_req zone=web_rate burst=120 nodelay;
        proxy_pass http://web_backend/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }
}

# API subdomain redirect
server { listen 80; server_name api.fkstrading.test api.fkstrading.xyz; return 301 https://$host$request_uri; }
server {
    listen 443 ssl;
    http2 on;
    server_name api.fkstrading.test api.fkstrading.xyz;
    ssl_certificate     /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;
    client_max_body_size 50M;
    location = /health { access_log off; return 200 "api:ok\n"; }
    location / {
        limit_req zone=api_rate burst=60 nodelay;
        proxy_pass http://api_backend$request_uri;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_read_timeout 300s;
    }
}

# Data subdomain redirect + service
server { listen 80; server_name data.fkstrading.test data.fkstrading.xyz; return 301 https://$host$request_uri; }
server {
    listen 443 ssl;
    http2 on;
    server_name data.fkstrading.test data.fkstrading.xyz;
    ssl_certificate     /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;
    location = /health { access_log off; return 200 "data:ok\n"; }
    location / {
        proxy_pass http://data_backend/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

# Auth subdomain (your Rust auth service)
server { listen 80; server_name auth.fkstrading.test auth.fkstrading.xyz; return 301 https://$host$request_uri; }
server {
    listen 443 ssl;
    http2 on;
    server_name auth.fkstrading.test auth.fkstrading.xyz;
    ssl_certificate     /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;
    location = /health { access_log off; return 200 "auth:ok\n"; }
    location / {
        proxy_pass http://auth_backend/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
